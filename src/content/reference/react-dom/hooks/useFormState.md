---
标题: 使用表单状态
金丝雀: 真的
---

<金丝雀>

`使用表单状态` 钩 目前仅在 反应 的金丝雀和实验通道中可用。详细了解[发布渠道](/社区/版本控制-政策#全部-发布-渠道)。此外，您需要使用支持 反应服务器组件](/参考/反应/使用客户端) 的框架才能充分发挥 使用表单状态 的优势。

</金丝雀>

<Intro>

`使用表单状态` 是一个 钩，允许您根据表单操作的结果更新状态。

```js
常量 [状态、表单动作] = 使用表单状态(号, 初始状态);
```

</Intro>

<InlineToc />

---

##参考 {/*参考*/}

### `使用表单状态(动作，初始状态)` {/*使用表单状态*/}

{/* 待办 T164397693: 链接到操作文档（一旦存在） */}

称呼 `使用表单状态` 在组件的顶层创建更新的组件状态 [当调用表单操作时](/参考/反应-多姆/成分/形式). 你过关了 `使用表单状态` 现有的表单操作函数以及初始状态，它返回您在表单中使用的新操作以及最新的表单状态。最新的表单状态也会传递给您提供的函数。

```js
进口 { 使用表单状态 } 从 "反应-多姆";

异步函数增量(先前状态，表单数据) {
  返回前一个状态 + 1;
}

函数 有状态表单({}) {
  常量 [状态、表单动作] = 使用表单状态(增量, 0);
  返回 (
    <形式>
      {状态}
      <按钮 表单动作 = {表单动作}>增量</按钮>
    </形式>
  )
}
```
表单状态是上次提交表单时操作返回的值。如果表单尚未提交，则为您通过的初始状态。

如果与服务器操作一起使用, `使用表单状态` 允许在 Hydration 完成之前显示服务器提交表单的响应。

[请参阅下面的更多示例.](#用法)

#### 参数 {/*参数*/}

* `号`:提交表单或按下按钮时要调用的函数。当函数被调用时，它将接收表单的先前状态（最初是您传递的“初始状态”，随后是其先前的返回值）作为其初始参数，后面是表单操作通常接收的参数。
* `初始状态`：您希望初始状态的值。它可以是任何可序列化的值。首次调用操作后，该参数将被忽略。

{/* 去做 T164397693：链接到可序列化值文档（一旦存在） */}

#### 退货 {/*退货*/}

`使用表单状态`返回一个恰好有两个值的数组:

1. 目前的状态。在第一次渲染期间，它将匹配您传递的 “初始状态”。调用操作后，它将匹配操作返回的值。
2.一个新操作，您可以将其作为“行动”道具传递给 “形式” 组件，或将 “表单动作” 道具传递给表单中的任何 “按钮” 组件。

#### 注意事项 {/*注意事项*/}

* 与支持 反应 Server 组件的框架一起使用时, `使用表单状态` 允许您在 爪哇脚本 在客户端上执行之前使表单具有交互性。当不使用服务器组件时，它相当于组件本地状态。
* 该函数传递给 `使用表单状态`接收一个额外的参数，即先前或初始状态，作为其第一个参数。这使得它的签名不同于直接用作表单操作而不使用 `使用表单状态`.

---

## 用法 {/*用法*/}

### 使用表单操作返回的信息 {/*使用-信息-回-经过-诶-形式-行动*/}

称呼 `使用表单状态` 在组件的顶层访问上次提交表单时操作的返回值。

```js [[1, 5, "状态"], [2, 5, "表单动作"], [3, 5, "行动"], [4, 5, "无效的"], [2, 8, "表单动作"]]
进口 { 使用表单状态 } 从 '反应-多姆';
进口 { 行动 } 从 './行动.js';

功能 我的组件() {
  常量 [状态, 表单动作] = 使用表单状态(行动, 无效的);
  // ...
  返回 (
    <形式 行动={表单动作}>
      {/* ... */}
    </形式>
  );
}
```

`使用表单状态` 返回 恰好包含两个项目的数组:

1. 表单的<代码步骤 步={1}>当前状态</代码步骤>，最初设置为您提供的<代码步骤 步={4}>初始状态</代码步骤>，并在表单提交后设置为您提供的 <代码步骤 步={3}>行动</代码步骤> 的返回值。
2. 诶 <代码步骤 步={2}>新的 行动</代码步骤> 你传递给 `<形式>` 就像它一样 `行动` 支柱.

当。。。的时候 形式 已提交, 这 <代码步骤 步={3}>行动</代码步骤> 功能 您提供的将被称为. 它是 返回 价值将成为新的 <代码步骤 步={1}>当前的 状态</代码步骤> 的 形式.

这 <代码步骤 步={3}>行动</代码步骤>您提供的还将收到一个新的第一个参数，即 <代码步骤 步={1}>当前的 状态</代码步骤> 的 形式. 第一次 形式 已提交，这将是 <代码步骤 步={4}>最初的 状态</代码步骤>您提供的，而后续提交的内容将是 返回 价值 从 上次的 行动 被称为。其余参数与假设相同 `使用表单状态` 没有被使用过

```js [[3, 1, "行动"], [1, 1, "当前状态"]]
功能 行动(当前状态, 形式数据) {
  // ...
  返回 '下一个状态';
}
```

<食谱 标题文本="展示 信息 提交后 形式" 标题ID="展示-信息-后-提交-	诶-形式">

#### 展示 形式 错误 {/*展示-形式-错误*/}

显示 信息s 比如一个错误 信息 或吐司那是 返回 通过服务器 行动, 包裹住 行动 在通话中 `使用表单状态`.

<Sandpack>

```js 应用程序.js
进口 { 使用状态 } 从 "反应";
进口 { 使用表单状态 } 从 "反应-多姆";
进口 { 添加到购物车 } 从 "./行动.js";

功能 添加到购物车表格({物品ID, 项目标题}) {
  常量 [信息, 表单动作] = 使用表单状态(添加到购物车, 无效的);
  返回 (
    <形式 行动={表单动作}>
      <h2>{项目标题}</h2>
      <输入 类型="隐" 姓名="物品ID" 价值={物品ID} />
      <按钮 类型="提交">添加到购物车</按钮>
      {信息}
    </形式>
  );
}

出口 默认 功能 应用程序() {
  返回 (
    <>
      <添加到购物车表格 物品ID="1" 项目标题="爪哇脚本: 权威指南" />
      <添加到购物车表格 物品ID="2" 项目标题="爪哇脚本: 好的部分" />
    </>
  )
}
```

```js 行动.js
"使用服务器";

出口 异步 功能 添加到购物车(上一页状态, 查询数据) {
  常量 物品ID = 查询数据.得到('物品ID');
  如果 (物品ID === "1") {
    返回 “已添加到购物车";
  } 别的 {
    返回 "无法添加到购物车：该商品已售完。";
  }
}
```

```css styles.css 隐
形式 {
  边界: 坚硬的 1px 黑色的;
  利润-底部: 24px;
  填充: 12px
}

形式 按钮 {
  利润-正确的: 12px;
}
```

```json package.json 隐
{
  "依赖关系": {
    "反应": "金丝雀",
    "反应-多姆": "金丝雀",
    "反应-脚本": "^5.0.0"
  },
  "主要的": "/i指数.js",
  "开发依赖": {}
}
```
</Sandpack>

<Solution />

#### 显示结构化 信息 提交后 形式 {/*展示-结构化的-信息-后-提交-诶-形式*/}

这 返回 价值 从 一台服务器 行动 可以是任何可序列化的值。例如， 它可以是一个包含布尔值的对象，指示是否 行动 成功了，出现错误 信息, 或更新 信息.

<Sandpack>

```js 应用程序.js
进口 { 使用状态 } 从 "反应";
进口 { 使用表单状态 } 从 "反应-多姆";
进口 { 添加到购物车 } 从 "./行动.js";

功能 添加到购物车表格({物品ID, 项目标题}) {
  常量 [形式状态, 表单动作] = 使用表单状态(添加到购物车, {});
  返回 (
    <形式 行动={表单动作}>
      <h2>{项目标题}</h2>
      <输入 类型="隐" 姓名="物品ID" 价值={物品ID} />
      <按钮 类型="提交">添加到购物车</按钮>
      {形式状态?.成功 &&
        <分区 班级姓名="吐司">
          已添加到购物车！您的购物车现在有 {形式状态.购物车尺寸} 项目.
        </分区>
      }
      {形式状态?.成功 === 错误的 &&
        <分区 班级姓名="错误">
          无法添加到购物车: {形式状态.信息}
        </分区>
      }
    </形式>
  );
}

出口 默认 功能 应用程序() {
  返回 (
    <>
      <添加到购物车表格 物品ID="1" 项目标题="爪哇脚本: 权威指南" />
      <添加到购物车表格 物品ID="2" 项目标题="爪哇脚本: 好的部分" />
    </>
  )
}
```

```js 行动.js
"使用服务器";

出口 async 功能 添加到购物车(prev状态, 查询数据) {
  常量 物品ID = 查询数据.get('物品ID');
  如果 (物品ID === "1") {
    返回 {
      成功: 真的,
      购物车尺寸: 12,
    };
  } 别的 {
    返回 {
      成功: 错误的,
      信息: "该商品已售完。",
    };
  }
}
```

```css styles.css 隐
形式 {
  边界: 坚硬的 1px 黑色的;
  利润-底部: 24px;
  填充: 12px
}

形式 按钮 {
  利润-正确的: 12px;
}
```

```json package.json 隐
{
  "依赖关系": {
    "反应": "金丝雀",
    "反应-多姆": "金丝雀",
    "反应-脚本": "^5.0.0"
  },
  "主要的": "/指数.js",
  "开发依赖": {}
}
```
</Sandpack>

<Solution />

</Recipes>

## 故障排除 {/*故障排除*/}

### 我的 行动 能 不 更长 读 这 提交 形式 数据 {/*我的-行动-能-不-更长-读-这-提交-形式-数据*/}

当你包裹一个 行动 和 `使用表单状态`, 它得到一个额外的参数 *作为它的第一个参数*. 这 提交 形式 数据 是 所以 它是 *第二* 参数而不是通常的第一个参数. 这 添加的新第一个参数是 这 当前的 状态 的 这 形式.

```js
功能 行动(当前的状态, 形式数据) {
  // ...
}
```
